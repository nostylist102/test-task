#ниже все подробно описал

# ---
# Deployment: Основной ресурс, описывающий желаемое состояние нашего приложения.
# Он управляет созданием и обновлением подов.
# ---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mindbox-sre-app
  labels:
    app: mindbox-sre-app
spec:
  # Количество реплик, которое будет поддерживаться по умолчанию.
  # HPA будет управлять этим значением, поэтому здесь мы ставим минимальное желаемое количество.
  replicas: 2
  selector:
    matchLabels:
      app: mindbox-sre-app
  # Стратегия обновления. RollingUpdate обеспечивает "бесшовный" деплой без даунтайма.
  strategy:
    type: RollingUpdate
    rollingUpdate:
      # maxUnavailable: 0 означает, что во время обновления количество доступных подов
      # не должно опускаться ниже заданного. Это критично для отказоустойчивости.
      maxUnavailable: 0
      # maxSurge: 1 позволяет создать один дополнительный под сверх нужного количества.
      # Новый под создается, проходит readiness-проверку, и только потом старый удаляется.
      maxSurge: 1
  template:
    metadata:
      labels:
        app: mindbox-sre-app
    spec:
      containers:
        - name: webapp
          # Здесь должно быть имя вашего образа приложения
          image: "my-webapp-image:latest"
          ports:
            - name: http
              containerPort: 8080
              protocol: TCP
          # ---
          # Настройка ресурсов - один из ключевых моментов.
          # ---
          resources:
            # requests - это гарантированное количество ресурсов, которое будет выделено поду.
            # Планировщик Kubernetes использует это значение для выбора ноды.
            # HPA также ориентируется на requests при расчете утилизации.
            requests:
              # По условию, в дальнейшем потребление ровное в районе 0.1 CPU.
              # Запрашиваем именно это количество, чтобы не резервировать лишнего.
              cpu: "100m" # 0.1 CPU
              # По памяти всегда "ровно" в районе 128M.
              memory: "128Mi"
            # limits - это максимальное количество ресурсов, которое может потреблять контейнер.
            limits:
              # На первые запросы требуется значительно больше ресурсов CPU.
              # Устанавливаем высокий лимит, чтобы позволить приложению "разгоняться" (burst).
              # Если на ноде есть свободный CPU, под сможет его использовать.
              cpu: "500m" # 0.5 CPU
              # Потребление памяти ровное, поэтому лимит равен запросу.
              # Это дает поду QoS-класс "Guaranteed" по памяти, что повышает его стабильность.
              memory: "128Mi"
          # ---
          # Проверки готовности и жизнеспособности.
          # ---
          readinessProbe:
            # Проверяет, готово ли приложение принимать трафик.
            httpGet:
              path: /healthz # Предполагаем, что у приложения есть эндпоинт для проверок
              port: http
            # initialDelaySeconds > время инициализации приложения (5-10 секунд).
            # Даем приложению время запуститься перед первыми проверками.
            initialDelaySeconds: 15
            periodSeconds: 5
            failureThreshold: 3
          livenessProbe:
            # Проверяет, не "зависло" ли приложение. Если проверка падает, kubelet перезапустит контейнер.
            httpGet:
              path: /healthz
              port: http
            initialDelaySeconds: 15
            periodSeconds: 10
            failureThreshold: 3
      # ---
      # Распределение подов по зонам доступности для максимальной отказоустойчивости.
      # ---
      topologySpreadConstraints:
        - maxSkew: 1
          # topology.kubernetes.io/zone - стандартный ключ для зон доступности в облачных провайдерах.
          topologyKey: "topology.kubernetes.io/zone"
          # DoNotSchedule - строгое правило. Если планировщик не может удовлетворить этому правилу,
          # под не будет запущен.
          whenUnsatisfiable: DoNotSchedule
          labelSelector:
            matchLabels:
              app: mindbox-sre-app

---
